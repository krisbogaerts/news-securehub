{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"ENHANCE - a golang terminal UI for GitHub Actions","url":"https://www.reddit.com/r/golang/comments/1nwdarl/enhance_a_golang_terminal_ui_for_github_actions/","date":1759433078,"author":"/u/e-lys1um","guid":625,"unread":true,"content":"<p>I'm very excited to share what I've been working on!</p><p>Introducing , a terminal UI for GitHub Actions that lets you easily see and interact with your PRs checks.</p><p>It's available under a sponsorware model, more info on the site:</p><p>This is an attempt to make my OSS development something sustainable. Happy to hear feedback about the model as well as the tool!</p>","contentLength":350,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Who's Hiring - October 2025","url":"https://www.reddit.com/r/golang/comments/1nwab02/whos_hiring_october_2025/","date":1759426425,"author":"/u/jerf","guid":622,"unread":true,"content":"<p>This post will be stickied at the top of until the last week of October (more or less).</p><p>: It seems like Reddit is getting more and more cranky about marking external links as spam. A good job post obviously has external links in it. If your job post does not seem to show up please send modmail.  because Reddit sees that as a huge spam signal. Or wait a bit and we'll probably catch it out of the removed message list.</p><p>Please adhere to the following rules when posting:</p><ul><li>Don't create top-level comments; those are for employers.</li><li>Feel free to reply to top-level comments with on-topic questions.</li><li>Meta-discussion should be reserved for the distinguished mod comment.</li></ul><ul><li>To make a top-level comment you must be hiring directly, or a focused third party recruiter with <strong>specific jobs with named companies</strong> in hand. No recruiter fishing for contacts please.</li><li>The job must be currently open. It is permitted to post in multiple months if the position is still open, especially if you posted towards the end of the previous month.</li><li>The job must involve working with Go on a regular basis, even if not 100% of the time.</li><li>One top-level comment per employer. If you have multiple job openings, please consolidate their descriptions or mention them in replies to your own top-level comment.</li><li>Please base your comment on the following template:</li></ul><p><em>[Company name; ideally link to your company's website or careers page.]</em></p><p><em>[Full time, part time, internship, contract, etc.]</em></p><p><em>[What does your team/company do, and what are you using Go for? How much experience are you seeking and what seniority levels are you hiring for? The more details the better.]</em></p><p><em>[Where are your office or offices located? If your workplace language isn't English-speaking, please specify it.]</em></p><p><em>[Please attempt to provide at least a rough expectation of wages/salary.If you can't state a number for compensation, omit this field. Do not just say \"competitive\". Everyone says their compensation is \"competitive\".If you are listing several positions in the \"Description\" field above, then feel free to include this information inline above, and put \"See above\" in this field.If compensation is expected to be offset by other benefits, then please include that information here as well.]</em></p><p><em>[Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]</em></p><p><em>[Does your company sponsor visas?]</em></p><p><em>[How can someone get in touch with you?]</em></p>","contentLength":2403,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"qbecc is a C compiler producing Go ABI0 assembler","url":"https://www.reddit.com/r/golang/comments/1nw7xmk/qbecc_is_a_c_compiler_producing_go_abi0_assembler/","date":1759421152,"author":"/u/0xjnml","guid":624,"unread":true,"content":"<p>The resulting assembler code runs on standard Go movable stacks. This is another way how to avoid the cost of CGo Go&lt;-&gt;C context switch. However, as no silver bullets exist, the cost of running on movable stacks is not gone in full. It have shifted to the additional handling of goroutine-local allocations for addressable local variables. </p><p>The purpose of this experiment is to compare the <a href=\"http://modernc.org/ccgo/v4\">modernc.org/ccgo/v4</a> and qbecc approaches with respect to resulting performance differences, if any. </p>","contentLength":489,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Subtest grouping in Go","url":"https://www.reddit.com/r/golang/comments/1nw4hfp/subtest_grouping_in_go/","date":1759413366,"author":"/u/sigmoia","guid":621,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/sigmoia\"> /u/sigmoia </a>","contentLength":30,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Breaking down Go's sync package","url":"https://mfbmina.dev/en/posts/2025-09-19_sync-break-down/","date":1759406683,"author":"/u/mfbmina","guid":623,"unread":true,"content":"<p>In my opinion, Go provides excellent support for concurrent work, not only due to goroutines but also because of the language’s ecosystem. A great example of this is the <a href=\"https://pkg.go.dev/sync\" target=\"_blank\" rel=\"noopener noreffer\">sync</a> package, which helps synchronize concurrent routines. In this post, we’ll dive into everything this package has to offer.</p><p>Waitgroups are used to coordinate the execution of multiple routines. They make it easy to create and ensure that all sub-routines will finish before the main routine ends. In the post about <a href=\"https://mfbmina.dev/en/posts/waitgroups/\" rel=\"\">waitgroups</a> I explain better how they work and what changed with Go version 1.25.</p><p>Mutex stands for mutual exclusion locker. Its function is to lock access to a resource while an operation is being executed, preventing other routines from trying to write to that resource at the same time. For example, what is the return of the following function?</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>If your answer was 1000, there’s a chance you might have gotten it right, but it’s unlikely. This happens because, as routines are executed concurrently, they might try to write to the resource at the same time. To ensure this doesn’t happen, simply add a mutex and lock access to that resource.</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>Usage is quite simple: to lock access to a record you use the  function, and when finished, just use . You just need to be careful not to fall into <a href=\"https://en.wikipedia.org/wiki/Deadlock_%28computer_science%29\" target=\"_blank\" rel=\"noopener noreffer\">deadlock</a>. There’s also the  function, which validates whether an active lock exists or not, but its use case is rarer.</p><p>The RW Mutex is an evolution of the mutex where there are specific locks for writing and reading. This distinction is quite useful when one or more routines need to access a resource for reading only, but don’t want the object to be modified during its execution. However, it’s important to mention that writing has higher priority than reading, and thus, Go avoids <a href=\"https://en.wikipedia.org/wiki/Starvation_%28computer_science%29\" target=\"_blank\" rel=\"noopener noreffer\">starvation</a>.</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code></code></pre></td><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>In the example above, we can have several routines calling  to get the average of the integer list. However, if a routine decides to insert another value, everyone will have to wait for that write to finish.</p><p>The <a href=\"https://pkg.go.dev/sync/atomic\" target=\"_blank\" rel=\"noopener noreffer\">atomic</a> is a subpackage of the sync package that implements concurrency support for primitive types. Currently, it supports the following types: , , , , , , , and . With it, we can simplify the example used in the mutex:</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>It’s necessary to note that basic operations, such as addition, have been re-implemented to ensure that routines do not contend for the resource.</p><p>The  is like any other normal . It provides functions to compare, swap, assign or retrieve values, with the difference that it is safe for concurrency.</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>The documentation itself suggests it should be used in two cases:</p><ol><li>When a key is written only once, but read multiple times. An example is a cache that only grows.</li><li>When multiple goroutines read and write distinct groups of keys.</li></ol><p>Any other case is better to use the traditional map with mutexes.</p><p>The  type guarantees that something will be executed only once, even if multiple routines try to execute it. An example of this could be resource initialization, as demonstrated by the Go documentation.</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>It’s important to note that if the function panics, it will not be re-executed.</p><p>As the name suggests,  works based on a conditional, meaning that when something happens, it releases the execution of a routine. This execution can be released one by one using the  function or activating all at once with .</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code></code></pre></td><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>First, we initialize a  with some , an interface that implements the  and  functions. In the example, we use a mutex. When initializing each goroutine, it’s necessary to ensure the lock and then we put it in a waiting state with , which releases the lock, allowing new routines to be started. When a routine is released with  or ,  acquires the  again and releases the code execution. Go’s documentation recommends that  happens inside a loop waiting for a condition, because  alone can’t tell if something has happened or not, but this is not strictly necessary. The general flow then is:</p><p><code>goroutine acquires the lock</code> →  →  →  →  →  →  → <code>goroutine releases the lock</code></p><p>The  provides a way to deal with short-lived objects in memory. This helps relieve pressure on the GC, as memory space is always reused. The official documentation cites the  package as an example, which uses pools as temporary output buffers that adjust their size as needed.</p><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></td></tr></tbody></table></div></div><p>To initialize a  we need to define its initialization function. When using  we retrieve what is saved in memory and with  we write a new value to it.  is only used if there is nothing allocated into the memory.</p><p>The  package provides several functionalities that are extremely useful when working with multiple goroutines. It’s possible to control execution with  and  types.  ensure everything will be executed. , , and atomic types prevent resource contention. Finally,  relieves the GC’s work when it’s possible to work with short-lived objects in memory. Without a doubt, this package is crucial for anyone working with goroutines. If you wish to understand the implementation details of this package, I recommend watching the talk presented at Gophercon UK 2025, <a href=\"https://www.youtube.com/watch?v=DOj1G7CMT-I\" target=\"_blank\" rel=\"noopener noreffer\">Deep dive into the sync package</a> by Jesus Hawthorn. There is also a <a href=\"https://mfbmina.dev/en/talks/easing_concurrency_with_the_sync_package/\" rel=\"\">talk</a> that I presented at Golang SP about it. Tell me in the comments if you have already used this package and if it helped you in any way. If you haven’t used it yet, comment on what you thought of the post.</p>","contentLength":5320,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1nw1w4g/breaking_down_gos_sync_package/"},{"title":"QJS: Run JavaScript in Go without CGO using QuickJS and Wazero","url":"https://www.reddit.com/r/golang/comments/1nw0djm/qjs_run_javascript_in_go_without_cgo_using/","date":1759401910,"author":"/u/lilythevalley","guid":626,"unread":true,"content":"<p>Hey, I just released version 0.0.3 of my library called QJS.</p><p>QJS is a Go library that lets us run modern JavaScript directly inside Go, without CGO.</p><p>The idea started when we needed a plugin system for Fastschema. For a while, we used goja, which is an excellent pure Go JavaScript engine. But as our use cases grew, we missed some modern JavaScript features, things like full async/await, ES2023 support, and tighter interoperability.</p><p>That's when QJS was born. Instead of binding to a native C library, QJS embeds the QuickJS (NG fork) runtime inside Go using WebAssembly, running securely under Wazero. This means:</p><ul><li>A fully sandboxed, memory-safe runtime.</li></ul><p>Here's a quick benchmark comparison (computing factorial(10) one million times):</p><table><thead><tr></tr></thead><tbody><tr></tr></tbody></table><p><em>Please refer to repository for full benchmark details.</em></p><ul><li>Full ES2023 compatibility (with modules, async/await, BigInt, etc.).</li><li>Secure, sandboxed webassembly execution using Wazero.</li><li>Zero-copy sharing of Go values with JavaScript via ProxyValue.</li><li>Expose Go functions to JS and JS functions back to Go.</li></ul><p>The project took inspiration from Wazero and the clever WASM-based design of ncruces/go-sqlite3. Both showed how powerful and clean WASM-backed solutions can be in Go.</p><p>If you've been looking for a way to run modern JavaScript inside Go without CGO, QJS might suit your needs.</p><p>I'd love to hear your thoughts, feedback, or any feature requests. Thanks for reading!</p>","contentLength":1382,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}