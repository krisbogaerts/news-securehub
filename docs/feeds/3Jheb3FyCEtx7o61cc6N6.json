{"id":"3Jheb3FyCEtx7o61cc6N6","title":"Reddit - NetSec","displayTitle":"Reddit - NetSec","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Sliver C2 vulnerability enables attack on C2 operators through insecure Wireguard network","url":"https://hngnh.com/posts/Sliver-CVE-2025-27093/","date":1763731197,"author":"/u/catmandx","guid":6054,"unread":true,"content":"<p>Sliver is a powerful command and control (C2) framework designed to provide advanced capabilities for covertly managing and controlling remote systems.</p><p>Sliver supports Wireguard as a transport protocol with a custom Wireguard netstack. It is popular due to the open-source nature as well as extensibility, ease-of-use, and compatibility with Cobalt Strike BOFs. In versions 1.5.43 and earlier, the netstack does not limit traffic between Wireguard clients. This allows clients to communicate with each other without restrictions, potentially enabling leaked or recovered keypairs to be used to  or allowing port forwardings to be accessible from other implants.</p><p>These Sliver versions are affected: Sliver 1.5.43 and earlier.</p><p>Operators that use Wireguard protocol transport and port forwarding to access implants.</p><blockquote><p>Notes: images use colored border to show you where the command is executed:</p><ul></ul></blockquote><p>When the C2 Operator use the Wireguard functionality in Sliver, they need to:</p><ul><li>Create a Wireguard listener (a peer).\n    <div><div><code><table><tbody><tr><td><pre>  sliver &gt; wg -l 10002 -p\n\n  [*] Starting Wireguard listener\n  [*] Successfully started job #1\n</pre></td></tr></tbody></table></code></div></div><p>Now Sliver is listening on UDP port 10002 for Wireguard connections.</p></li><li>Create an implant with the  option.\n    <div><div><code><table><tbody><tr><td><pre>  sliver &gt; generate beacon --wg c2.server.com:10002 --debug --skip-symbols --name beacon-wg\n</pre></td></tr></tbody></table></code></div></div><p>This will embed a wireguard peer configuration inside the implant.</p></li><li>Execute the implant on the victim‚Äôs machine:\n    <div><div><code><table><tbody><tr><td><pre>  Victim powershell $ .\\beacon-wg.exe\n</pre></td></tr></tbody></table></code></div></div><p>\n  Now the implant becomes a Wireguard peer. The beacon should pop up on the operator‚Äôs sliver console:\n  \n  We can see the Wireguard private IP assigned to it is 100.64.0.4.</p></li><li>Create operator Wireguard config:\n    <div><div><code><table><tbody><tr><td><pre>  sliver &gt; wg-config -s ./data/wireguard/wg_confs/wg0.conf\n</pre></td></tr></tbody></table></code></div></div></li><li>The operator connect his own machine to the wireguard listener:\n    <div><div><code><table><tbody><tr><td><pre>  bash # wg-quick up wg0\n  bash # ip a\n</pre></td></tr></tbody></table></code></div></div><p>We can see the Wireguard private IP assigned to the operator is 100.64.0.2.</p></li></ul><p>To facilitate port forwarding, Sliver implement the wireguard network stack to <strong>forward any packets between peers</strong>, this essentially create a traditional hub-and-spoke VPN server. Traffic between wireguard peers are not filtered .</p><p>On the Sliver server and on the victim machine, the wireguard connection is not exposed as a network interface, it lives entirely inside the process.</p><p>Crucially, if the operator uses  or any equivalent commands, they are <strong>creating a network interface</strong> on their machine. If they have any services listening on 0.0.0.0 (SSH, RDP, SMB, HTTP, etc), those services <strong>can also be accessed on the 100.64.0.2 interface</strong> by other wireguard peers.</p><p>We can verify this behavior by perform pings from both sides:</p><ul><li>On the operator machine, we can ping the beacon since the OS knows where to send ICMP packets:</li></ul><ul><li>In contrast, the victim machine is not aware that there‚Äôs a VPN connection since it only lives inside the beacon process, thus the ping fails:</li></ul><p>If a defender or malicious client get ahold of the wireguard config used by the client, then they can connect to the Sliver wireguard listener, and connect to the operator‚Äôs wireguard interface. Getting the wireguard connection config from the beacon is outside the scope of this article, the wireguard config is embedded into the beacon at compile time, as well as existing in memory, you can dump the memory or use some static analysis tool to retrieve the sliver wireguard. listener address, private key of the beacon and public key of the sliver listener.</p><p>First you have to obtain a valid wireguard config, there are several ways to do this, exercise left to the reader, then creating a network interface using it:</p><h3><a href=\"https://hngnh.com/posts/Sliver-CVE-2025-27093/#scenario-1-attacking-the-operator\"></a></h3><p>The victim can connect to the operator‚Äôs machine:</p><p>Assuming the operator is running an HTTP server on their machine, the victim can now connect to it, the same applies to any services listening on 0.0.0.0:</p><h3><a href=\"https://hngnh.com/posts/Sliver-CVE-2025-27093/#scenario-2-attacking-other-beaconsvictims\"></a></h3><p>If the operator has set up port forwarding to access services inside a victim‚Äôs internal network, something like 100.64.0.4:1080 ‚Äì&gt; internal-ad-server.corp.local:445</p><p>Then other victims/beacons can also connect to that port forward, though this require some serious guesswork:</p><h2><a href=\"https://hngnh.com/posts/Sliver-CVE-2025-27093/#gaining-persistence-with-stealth\"></a></h2><p>When the beacon is executed on the victim machine, it will notify the Sliver server that a beacon has connected. This will only happen if you let the beacon finish handshaking with the server. This process is as follows:</p><ul><li>Step 1: the beacon use the embedded wireguard peer config to establish connection with the server. This embedded config will be shared with every other beacon, so it will only be used to initiate the connection before switching to a new config.</li><li>Step 2: the beacon connect to 100.64.0.1:1337 (default key exchange endpoint) and receive a new, unique wireguard peer config.</li><li>Step 3: perform handshake and let the operator know the beacon is online.</li></ul><p>If you are able to extract the initial Wireguard peer configuration, you can use it as-is to connect to the Wireguard listener, but if you keep using it, other beacons with the same executable will not be able to connect back, so this will generate some suspicion on the operator‚Äôs side.</p><p>If the operator use the default configuration, you can use netcat to connect to 100.64.0.1:1337 and get a new, unencrypted Wireguard config unique to you, this way you gain access to the network while not letting them know you are there, the Sliver console does not have a way to show how many Wireguard config has been created, or how many is currently connected.</p><ul><li>https://github.com/BishopFox/sliver/security/advisories/GHSA-q8j9-34qf-7vq7</li><li>https://nvd.nist.gov/vuln/detail/CVE-2025-27093</li></ul>","contentLength":5505,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p2yexv/sliver_c2_vulnerability_enables_attack_on_c2/"},{"title":"Esbuild XSS Bug That Survived 5B Downloads and Bypassed HTML Sanitization","url":"https://www.depthfirst.com/post/esbuilds-xss-bug-that-survived-5-billion-downloads-and-bypassed-html-sanitization","date":1763683387,"author":"/u/va_start","guid":5992,"unread":true,"content":"<p>Esbuild has been downloaded 5 billion times since this XSS bug was introduced in 2022. The bug hid in a function that promised to escape html called . But, apparently, the promise was more of a suggestion. To bypass the HTML escaping, I used the , literally a quote . A malicious folder with a quote in its name could be used to attack anyone using the dev server. The fix was one line. The exploit involved making an invisible script take over your entire screen.&nbsp;</p><h2>The Initial Finding: Suspicious XSS</h2><p>This adventure kicked off with our depthfirst system tapping me on the shoulder like an overeager intern with a suspiciously confident smile.</p><h4>&gt;  XSS in esbuild dev server</h4><h4>: github.com/evanw/esbuild (40k Github stars)<code>html.WriteString(escapeForHTML( ... ))</code></h4><p>In esbuild? Using a function literally named? Unlikely. I had the same reaction you‚Äôd have if someone told you a toaster was capable of launching a space shuttle: charming, but wrong.</p><p>Our system claimed there‚Äôs an XSS bug <em>inside code designed to prevent XSS</em>? <em>In a major codebase built around generating safe HTML</em>? If true, that‚Äôs like finding out the lifeguard can't swim.</p><p>Still, if valid, this would be a significant finding. The esbuilt npm package alone has five billion downloads. And a restless ‚Äúbut what if?‚Äù rang in the back of my mind. So I sighed, cracked my knuckles, and set out to prove the machine wrong. Spoiler: the machine was  wrong.</p><h2>The Investigation: A Friendly Challenge Turns Into a Rabbit Hole</h2><p>The depthfirst system had already labeled it ‚Äúlow severity,‚Äù which is our polite way of telling engineers, ‚Äúnot a fire, but this smells funny.‚Äù</p><p>But I couldn‚Äôt let it go. Even when a machine says ‚Äúlow severity,‚Äù I still want to understand  it thinks something is off. It‚Äôs like hearing your dog growl at a blank wall. Maybe it‚Äôs nothing, but maybe it‚Äôs time to call a priest.</p><p>So I followed the trail into esbuild‚Äôs code.</p><p>Here‚Äôs the vulnerable code :</p><pre contenteditable=\"false\"><code>}\n\t}\n\t\t}\n\t\thtml.WriteString(escapeForHTML(part))\n\t\t}\n\t}\n}</code></pre><p>At first, nothing seemed odd. The dev server is creating the  title from directory listings. It's escaping&nbsp; HTML in the folder names. All the classics get neutralized: </p><p>But one thing  get escaped. Quotes .</p><p>I have confirmed our system's finding and suddenly everything clicked into place. I gave my laptop a pat on the head to reward the AI.</p><h3>HTML 101: The Difference Between Text and Attributes</h3><p> correctly protects you when you put user-controlled text  tags, like:</p><pre contenteditable=\"false\"><code></code></pre><p>But esbuild wasn‚Äôt putting the escaped text there. It was putting it  an HTML attribute, in an :</p><pre contenteditable=\"false\"><code></code></pre><p>If your sanitization doesn‚Äôt escape double quotes, you can break out of the attribute and add your own. You can slap on a new , an event handler, or an entire circus of JavaScript!</p><p>The correct function to use was :</p><pre contenteditable=\"false\"><code>\ttext = escapeForHTML(text)\n}\n</code></pre><h2>Crafting the Exploit: Making an Invisible Screen-Sized Mousetrap</h2><p>Once I realized I could break out of the attribute, the rest was pure puzzle-solving joy.</p><p>I needed a folder name that:</p><ol role=\"list\"><li>Included a double quote to terminate the attribute</li><li>Added a malicious attribute to execute Javascript</li><li>Worked even though esbuild would automatically append  at the end</li><li>Easily triggered (because asking a user to click a link isn't sexy).</li></ol><p>Here‚Äôs the command that created the malicious directory:</p><pre contenteditable=\"false\"><code></code></pre><ul role=\"list\"><li><code>style=\"position:absolute;top:0;left:0;width:100vw;height:100vh;\"</code>This creates an invisible full-screen div. This is important for the next part.</li></ul><ul role=\"list\"><li><code>onmouseover=\"alert('xss')\"</code>The moment your cursor moves over the div, which is now the whole screen, boom. Arbitrary JavaScript execution.</li></ul><ul role=\"list\"><li>This dummy attribute was the key to neutralizing esbuild‚Äôs auto-appended /\". I needed a place to  the trailing characters so they don't cause a syntax error in the other attributes.</li></ul><p>Reload the dev server. Move your mouse. Instant satisfaction.</p><h2>The Fix: A One-Word Patch and a Thoughtful Maintainer</h2><p>After confirming the exploit was real, I sent the automatically generated fix upstream. <a href=\"https://github.com/evanw/esbuild/pull/4316/commits/7fd5ce6c46ecfbfb846b2a04cedae91dfbcd4c7d\">The patch</a> was immediately merged.</p><p>The fix? Literally a swap:</p><pre contenteditable=\"false\"><code>+ escapeForAttribute(...)</code></pre><p>One word. Billions of future downloads affected.</p><p>I love bugs like this. They're subtle, and make you think deeply about the edge cases of the code.</p><p>The maintainers thanked us for finding and fixing the bug, and was correct to point out this didn't have a security impact. Since this only affects the dev server, and the dev server assumes a trusted environment, it‚Äôs not a ‚Äúsecurity vulnerability‚Äù in the traditional sense. And that‚Äôs true. This wasn‚Äôt a CVE-worthy disaster. No one‚Äôs production servers were melting because of this.</p><p>But it was still a . An elusive, fun, intellectually stimulating bug that was completely exploitable.</p><p>And depthfirst‚Äôs system correctly found, categorized, and drafted a patch. All automatically.</p><p>I just got to be the human who enjoyed the ride.</p><p>This adventure felt like tugging on a loose thread in a sweater: you don‚Äôt expect much, but suddenly half the sleeve is in your hand. All I did was follow a quote mark out of an attribute, and it led to a bug that had been downloaded billions of times. The funny part is that nothing here was ‚Äúwrong‚Äù in isolation. The trick was noticing the context had changed.  was perfectly fine for text, just not for attributes.</p><p>Depthfirst surfaced the loose thread; I pulled it because I can‚Äôt resist seeing where those threads lead. Together, we solved a tiny mystery tucked away in a project downloaded five billion times.</p>","contentLength":5433,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p2jinz/esbuild_xss_bug_that_survived_5b_downloads_and/"},{"title":"Unquoted Paths: The Decades-Old Windows Flaw Still Enabling Hidden Code Execution","url":"https://spektion.com/articles/unquoted-path-flaw/","date":1763668024,"author":"/u/runtimesec","guid":5977,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p2d0ye/unquoted_paths_the_decadesold_windows_flaw_still/"},{"title":"When Updates Backfire: RCE in Windows Update Health Tools","url":"https://research.eye.security/rce-windows-update-health-tools/","date":1763622980,"author":"/u/vaizor","guid":5884,"unread":true,"content":"<p><strong>What if a Microsoft‚Äëtool meant to protect Windows machines</strong>,<strong> actually opened up remote code execution (RCE) by re-using abandoned Azure blobs?</strong></p><p>That‚Äôs exactly what we discovered in Microsoft‚Äôs Update Health Tools (<a href=\"https://support.microsoft.com/en-us/topic/kb4023057-update-health-tools-windows-update-service-components-fccad0ca-dc10-2e46-9ed1-7e392450fb3a\">KB4023057</a>), designed to speed security updates via Intune. While its aim, to help in fast roll‚Äëouts and emergency patches, is good, a flaw in its configuration meant many devices were exposed: attackers could trigger arbitrary code execution remotely.</p><p>In this post, we‚Äôll walk you through how we found this issue, how Microsoft has responded, and what you can do if your devices are still vulnerable. We‚Äôll cover the original version 1.0, the attack vector we leveraged, evidence from real‚Äëworld telemetry, and how newer versions have tried to plug the gap.</p><p>After reading <a href=\"https://labs.watchtowr.com/8-million-requests-later-we-made-the-solarwinds-supply-chain-attack-look-amateur/\">WatchTowr‚Äôs deep dive</a> on abandoned AWS S3 buckets earlier this year, we started wondering: how many Azure blob storage accounts could be silently dangling out there, just waiting to be claimed? So, we began looking, and started monitoring DNS traffic on our own Windows machines. And we found more than we expected.</p><p>Among the pile of findings, which will be covered in later blogs, one stood out: <code>payloadprod0.blob.core.windows.net</code> . This finding kicked off what would become a deep dive into remote code execution through a signed Microsoft tool.</p><p>Once we registered the storage account (), we began monitoring for inbound requests. Within hours, we were seeing hundreds of HTTP GET requests hitting the blobs, coming from all over the world. These requests targeted structured URIs like:</p><pre><code>GET /&lt;hash&gt;/enrolled.json  \nGET /&lt;hash&gt;/Devices/&lt;hash&gt;.json</code></pre><p>All with a consistent user agent: . What could that be?</p><p>Digging deeper, we queried EDR telemetry and found that , a Microsoft-signed binary known as the Update Health Service, was actively resolving these domains across multiple customer environments. This service lived in: <code>C:\\Program Files\\Microsoft Update Health Tools\\uhssvc.exe</code>. </p><p>Later, we found out that the Azure storage accounts used, followed a predictable naming pattern: <code>payloadprod0.blob.core.windows.net</code> through <code>payloadprod15.blob.core.windows.net</code>. When we checked, 10 of those 15 blobs were still unregistered. So we claimed them and started watching thousands of similar requests flowing in from all over the world.</p><p>The obvious next step? Figure out what these endpoints were trying to fetch, and whether we could influence what they received.</p><p>To understand , we first needed to trace how  actually works. Let‚Äôs start with the original version 1.0 of the update health tools. After some reverse engineering, we developed a hypothesis that the team within Microsoft writing this tool, probably needed an easy service to check which updates to install. They apparently decided to use Azure blob storages, with a container per tenant and a few JSON files to specify the configuration.</p><p>So what does  do, exactly?</p><ul><li>A new installation will start by checking if it‚Äôs Entra joined/registered. If not, it will simply stop as this is an enterprise tool.</li><li>The service checks whether this Entra tenant is enrolled into update management by downloading a file from <code>/&lt;tenant_hash&gt;/enrolled.json</code> and checking whether  is set to  in this JSON.</li><li>If the tenant is enrolled it will continue the process of enrolling itself. This means downloading another JSON from <code>/&lt;tenant_hash&gt;/Devices/&lt;device_id_hash&gt;.json </code>with only a single field containing the policy ID assigned to this computer.</li><li>After that, the Update Health Tools will start polling <code>/&lt;tenant_hash&gt;/Policies/&lt;policy_id&gt;/&lt;cpu&gt;_&lt;osbuild&gt;.json</code> .</li><li>It will then look at  to determine what to do.</li></ul><p>Opening up the binary in IDA gives us an easy list of actions we can specify:</p><p>Our interest was immediately piqued by the ‚ÄúExecuteTool‚Äù option. That sounds like an easy way to get code execution.</p><p>Scrolling through the <code>&lt;strong&gt;WSD::ToolExecutor::Execute&lt;/strong&gt;</code> function we see our first hurdle</p><p>It looks like we can only execute a Microsoft signed binary. Diving a bit deeper, we see that we actually need an executable with an embedded signature that‚Äôs signed by Microsoft. These are more rare, since most default windows executable are signed using catalog files. With catalog files you can sign a list of executables instead of signing each executable individually. This allows Microsoft to optimise checking of signatures and saves disk space.</p><p>Luckily there‚Äôs an easy target on each windows installation: . But then we hit a new roadblocker.</p><p>We were excited having found remote code execution in v1.0, and wanted to test it. Unfortunately for us, Microsoft no longer offers version v1.0 from February 2021 for download. Instead, it gives you v1.1 from December 2022. Still determined to get RCE in the latest version, we opened it up in IDA and found a second implementation for getting the config. üòÉ</p><p>No longer content with using simple Blob Storage, the developers apparently decided to implement a real web service in v1.1 at <code>devicelistenerprod.microsoft.com</code>. Furthermore, they added new storage accounts specifically designed for EU customers and a 2nd copy of the webservice at  and <code>devicelistenerprod.eudb.microsoft.com</code>. We weren‚Äôt able to register any of these storage accounts, nor these domain names.</p><p>So apparently we won‚Äôt have RCE inside the EU, which means all of our European customers at Eye Security are safe! üòâ</p><p>After some more reversing of v1.1, we unlocked the option of re-enabling the old blob storage based communication by setting the configuration parameter  to 1 in the registry. While also allowing us to test from the EU by changing <code>UHS.STORAGEACCOUNTENDPOINTEUDB</code> to a storage account we control.</p><h2>Remote Code Execution (RCE)</h2><p>So, for the old-school experience of popping a calc, we created the following JSON as payload.</p><pre><code>{\n&nbsp; \"RequestId\": \"00000000-0000-0000-0000-000000000001\",\n&nbsp; \"EnterpriseActionType\": \"ExecuteTool\",\n&nbsp; \"EnterpriseExecutableClientPath\": \"..\\\\..\\\\Windows\\\\explorer.exe\",\n&nbsp; \"EnterpriseExecutableClientParameters\": \"/root,C:\\\\Windows\\\\system32\\\\calc.exe\",\n&nbsp; \"EnterpriseExecutableClientPayload\": []\n}</code></pre><p>Which produced the expected result when testing:</p><h2>Overall impact of this vuln</h2><p>Of course, we didn‚Äôt try this on any machine we didn‚Äôt own, but we could use the access logs of Azure Blob storage to see how many machines we could have accessed. For this we‚Äôve collected logs for 7 days of traffic to the 10 storage accounts we registered.</p><p>In that period, we‚Äôve seen  from the Update Health Tools. These are coming from <strong>9.976 unique Azure tenants</strong>. Of these, we noticed  asking whether they should enroll. For these requests, we can‚Äôt distinguish whether it‚Äôs a single machine in this tenant or a whole fleet of machines. The devices looking for their configured policy can be individually identified. These are coming from  and .</p><p>Given the enormous install base of Windows, this is of course a tiny fraction of machines still running the old (1.0) version of Update Health Tools or having the backward compatible flag enabled for the newer version.</p><p>We reported this vulnerability to Microsoft on July 7 2025 and they confirmed the behavior on July 17. We successfully transferred ownership of these storage accounts to Microsoft on July 18. Therefore all endpoints should be safe now.</p><p>After seeing what impact this issue had, it‚Äôs of course good to reflect how secure design principles can be used to avoid such issues in the future. The obvious way to avoid such issues is of course to not remove azure storage accounts or domains that publicly released software connects to. You can keep storage accounts reserved and linked to your tenant with all data removed and public access disabled. This makes sure no attacker can register the account, while also providing ease of mind that no data can leak and no unexpected bills will arrive.</p><p>Looking a bit further into the root cause we see that the developers are confusing transport security with message security. It‚Äôs easy to be tricked into believing that since Microsoft owns the storage account and the certificates for the associated, the data received from the server can be trusted. This only means that the data was securely transmitted from public Azure services. What they should have done is sign the messages themselves. That way no matter who owns the storage account or has the ability to generate SSL certificates, they can still verify that the commands to be executed are signed by the correct Microsoft team.</p>","contentLength":8458,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p1wuc7/when_updates_backfire_rce_in_windows_update/"},{"title":"HelixGuard uncovers malicious \"spellchecker\" packages on PyPI using multi-layer encryption to steal crypto wallets.","url":"https://helixguard.ai/blog/malicious-spellcheckers-2025-11-19","date":1763609770,"author":"/u/Fit_Wing3352","guid":5873,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p1svnz/helixguard_uncovers_malicious_spellchecker/"},{"title":"Breaking Oracle‚Äôs Identity Manager: Pre-Auth RCE (CVE-2025-61757)","url":"https://slcyber.io/research-center/breaking-oracles-identity-manager-pre-auth-rce/","date":1763608723,"author":"/u/Mempodipper","guid":5874,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1p1siyi/breaking_oracles_identity_manager_preauth_rce/"}],"tags":["netsec"]}