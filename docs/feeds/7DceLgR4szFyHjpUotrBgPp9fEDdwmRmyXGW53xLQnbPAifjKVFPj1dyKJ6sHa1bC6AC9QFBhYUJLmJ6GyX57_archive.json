{"id":"7DceLgR4szFyHjpUotrBgPp9fEDdwmRmyXGW53xLQnbPAifjKVFPj1dyKJ6sHa1bC6AC9QFBhYUJLmJ6GyX57","title":"top scoring links : linux","displayTitle":"Reddit - Linux","url":"https://www.reddit.com/r/linux/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/linux/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Linus Torvalds Vents Over \"Completely Crazy Rust Format Checking\"","url":"https://www.phoronix.com/news/Linus-Torvalds-Rust-Formatting","date":1759462986,"author":"/u/unixbhaskar","guid":635,"unread":true,"content":"\nAfter Linus Torvalds yesterday <a href=\"https://www.phoronix.com/news/Torvalds-No-RISC-V-BE\">shot down RISC-V big endian prospects for the Linux kernel</a>, today he has used his authority to wage a war on \"crazy\" Rust code formatting as well as to critique poor text formatting.\n<p>In response to the recently submitted Direct Rendering Manager (DRM) subsystem pull request, Torvalds began by voicing his displeasure over the text formatting of it:\n</p><blockquote>\"Notice how there are multiple sub-areas: Alloc, DMA/Scatterlist, DRM and Rust.\n<p>But it's all just a random jumble, because you have apparently pasted it into your editor or MUA or whatever and dropped the indentation in the process.\n</p><p>What kind of *broken* editor are you using? I'm not trying to start an emacs or vi war here, but you seem to be using something truly broken.\n</p>...\n<p>Look, again, no logic and you've completely corrupted any multi-level indentation that presumably existed at some point judging by the organization.\n</p>...\n<p>Please make the explanations *readable*, not just a random jumble of words.\"</p></blockquote>Edlin is the line/text editor found on early versions of PC DOS and MS-DOS...\n<p>But then on a more technical note, Linus Torvalds went on to seek better clarity of Rust code formatting moving forward. When looking at the Rust DRM code added for Linux 6.18, Torvalds commented after looking at some of the new code:\n</p><blockquote>\"And on a more technical side: I absolutely detest the mindless and completely crazy Rust format checking.\n<p>I noticed that people added multiple\n</p><p>next to each other, so I turned them into\n</p>     xyz,\n  };\n<p>instead to make it easy to just add another crate without messing crap up. The use statements around it had that format too, so it all seemed sensible and visually consistent.\n</p><p>But then I run rustfmtcheck, and that thing is all bass-ackwards garbage. Instead of making it clean and clear to add new rules, it suggests\n</p><p>but I have no idea what the heuristics for when to use multiple lines and when to use that compressed format are.\n</p><p>This is just ANNOYING. It's automated tooling that is literally making bad decisions for the maintainability. This is the kind of thing that makes future conflicts harder for me to deal with.\n</p><p>Miguel, I know you asked me to run rustfmtcheck, but that thing is just WRONG. It may be right \"in the moment\", but it is\n</p><p> (a) really annoying when merging and not knowing what the heck the rules are\n</p><p> (b) it's bad long term when you don't have clean lists of \"add one line for a new use\"\n</p><p>Is there some *sane* solution to this? Because I left my resolution alone and ignored the horrible rustfmtcheck results.\n</p><p>I tried to google the rust format rules, and apparently it's this:\n</p><p>    https://doc.rust-lang.org/style-guide/index.html#small-items\n</p><p>can we please fix up whatever random heuristics? That small items thing may make sense when we're talking things that really are one common data structure, but the \"use\" directive is literally about *independent* things that get used, and smushing them all together seems entirely wrong.\n</p><p>I realize that a number of users seem to just leave the repeated\n</p>   use kernel::abc;\n<p>as separate lines, possibly *becasue* of this horrendous rustfmt random heuristic behavior.\"</p></blockquote>The post in full can be read on <a href=\"https://lore.kernel.org/lkml/CAHk-=wgO7S_FZUSBbngG5vtejWOpzDfTTBkVvP3_yjJmFddbzA@mail.gmail.com/T/#me533a148abe97c29e0e7150508c42345b2a64e13\">the LKML</a>.","contentLength":3174,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1nworgq/linus_torvalds_vents_over_completely_crazy_rust/"},{"title":"Security update (4 hours ago): Incident related to Red Hat Consulting GitLab instance","url":"https://www.reddit.com/r/linux/comments/1nwk3uy/security_update_4_hours_ago_incident_related_to/","date":1759449373,"author":"/u/fenix0000000","guid":634,"unread":true,"content":"<p>Intro: \"We are writing to provide an update regarding a security incident related to a specific GitLab environment used by our Red Hat Consulting team. Red Hat takes the security and integrity of our systems and the data entrusted to us extremely seriously, and we are addressing this issue with the highest priority\".</p>","contentLength":318,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Ladybird browser update (September 2025)","url":"https://www.youtube.com/watch?v=6vsjIIiODhY","date":1759448898,"author":"/u/InsectAlert1984","guid":636,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1nwjxmb/ladybird_browser_update_september_2025/"},{"title":"It's easy to take image rendering in a terminal as granted, let alone video rendering. It's so cool when you think about it.","url":"https://www.reddit.com/r/linux/comments/1nwaxlf/its_easy_to_take_image_rendering_in_a_terminal_as/","date":1759427776,"author":"/u/keremdev","guid":638,"unread":true,"content":"<div><p>Props to kitty/sixel devs for this, ofc it's terminal IO bound but it's still really really cool.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/keremdev\"> /u/keremdev </a>","contentLength":128,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"PixiEditor is now available on Flathub","url":"https://pixieditor.net/blog/2025/10/02/september-status/","date":1759394170,"author":"/u/flabbet","guid":637,"unread":true,"content":"<p>Hi, hello, and welcome to the September PixiEditor Status update! On today’s menu:</p><ul><li>New renderer and a story of great failure</li></ul><p>Flatpak is one of the package managers for Linux, which is designed to be the universal package manager for Linux software, especially GUI apps.</p><p>Up until now, PixiEditor was distributed via  and  formats. It was suboptimal, as integrating PixiEditor to your Linux desktop required more effort.</p><p>Flatpak solves that issue. It automatically integrates with your desktop environment and manages updates. So if you are on Linux, give it a try!</p><article data-astro-cid-qlydl7qi=\"\"></article><p>Due to the nature of PixiEditor, rendering is a  tricky part. Not only does Node Graph allows for arbitrary customizations, shaders and operations, PixiEditor has vector capabilities (rendering crisp vectors on small documents)\nand animations.</p><p>Here’s a quick comparison of new renderer with heavy animation</p><h3>Single threaded rendering</h3><p>PixiEditor renders on the UI Thread, which means that heavy graphs can lag or even freeze the UI.</p><p>The logical solution was to make rendering on a separate thread.</p><h4>My little render thread journey</h4><p>In short, Render Thread is a thing that runs in the background, independently of the main app and renders graphics at it’s own pace. So whenever the main app requests a new frame,\nrender thread grabs this request, renders and hands the frame to the main app.</p><p>And I really wish it was that simple. This will be a little technical, so if you are just interested in new features, feel free to skip it.</p><p>PixiEditor uses Vulkan and OpenGL for rendering. However, neither Vulkan nor OpenGL is “standalone”, we must first access Avalonia’s GPU context to hook our own rendering. We use Avalonia’s composition renderer to update the UI with rendered stuff.</p><p>Current renderer performs rendering “on demand”, meaning that each UI control sends a render request with its surface to draw on. It has a few benefits:</p><ul><li>No additional intermediate surfaces,</li><li>Out of the box “render only what you see” approach</li></ul><ul><li>More error-prone (surfaces might get disposed mid-flight)</li><li>Potentially rendering the same frame multiple times</li><li>It’s harder to manage renders and perform optimizations</li><li>It’s virtually impossible to make rendering on other thread</li></ul><p>So the very first step was to invert the rendering logic, so we have more control over each rendered frame.</p><p>Refresh request —&gt; UI control surface —&gt; Render to control’s surface</p><p>Refresh request —&gt; Render into intermediate surface —&gt; UI control renders intermediate surface</p><p>Having one managing system that decides what gets rendered and in what resolution opens up a lot of optimization possibilities.</p><p>For example if you have Node Graph opened and layer’s panel visible, the renderer will render layer’s preview only once in slightly higher resolution (because node previews are bigger), instead of rendering it twice\nin different resolutions.</p><p>Great, so we have a system that produces bitmaps/surfaces with all previews and frames, that are just grabbed by UI controls to display. So the next logical step is to render these asynchronously.</p><p>Before I decided to jump into building separate thread solution, I tried better rendering scheduling in the Avalonia’s UI Thread dispatcher. It is still one thread, but any lags should be “spread out” over a few frames.</p><p>At first it seemed to work really great, playing animations for heavy graphs was smooth and the UI was responsive. Unfortunately, after some time I discovered that manipulating heavy graphs (like moving a layer)\nresulted in degraded performance. Rendering a singular layer into the bitmap wasn’t slower than in previous renderer, but scheduler fired less often, so it seemed like it was laggy.</p><p>The only logical solution left at that time, was to implement separate render thread.</p><p>Remember the part where I mentioned we use Avalonia’s GPU context and compositor?\nYeah, to get a separate render thread I had to properly synchronize not only access to GPU API, but also render thread’s render loop with Avalonia’s compositor.</p><p>Well, it was. After many days of freezes, crashes and debugging, it seemed to finally work. I developed it on a test project, but still.</p><p>Until I ran PixiEditor with it…</p><p>It worked like a hot mess…</p><p>Something had to be done, I think the whole rework already took me a full 2 weeks, where one whole week was dedicated to render thread. Shipping renderer that provides worse performance is unacceptable, even\nif it’s better in some scenarios.</p><p>At that point, I already invested so much time into this. I decided to give up separate render thread for now. However the whole point of the rework was to fix freezes and improve the performance.</p><p>I got my shit together and facts straight.</p><p>&gt; <em>New rework solves laggy animation performance</em>\n&gt; <em>Manipulation performance is degraded due to background scheduler update rate</em></p><p>&gt; <em>Can’t I just fire rendering immediately when user manipulates the canvas and do background rendering for animation?</em></p><p>5 lines of code and problem solved.</p><p>It doesn’t completely replace separate thread solution. It still runs on the main thread, but it’s already much better. At least according to my tests.</p><p><em>(to any brave soul, if you want to play around render thread solution I made, check the  branch both for  and )</em></p><h3>GPU chunks and direct viewport rendering</h3><p>This optimization is quite exciting for me. It’s only related to drawing/painting performance, but it’s been on my mind since the beginning of version 2.0.</p><p>PixiEditor uses chunks for layers. So instead of storing full resolution layer it only stores chunks that have something in them. For example, if you have a 1024x1024 document, one layer of this document\nconsists of 4 chunks that are 256x256 each. If you only draw on one chunk, others won’t be stored in memory.</p><p>This system was developed for version 1.0 and lost its meaning during transition to 2.0. Due to the performance reasons we had to use intermediate, full resolution texture before drawing to the screen.\nWhich kills any benefits of chunks.</p><p>Why did it work like that? Well, version 1.0 had CPU-only rendering, and CPU chunks were a leftover from 1.0. I tried making them GPU a while ago, but it had major problems back then.</p><p>Fortunately, I managed to properly implement GPU chunk textures, which significantly improves rendering performance. Thanks to this, I was able to get rid of intermediate surface and draw the chunks\nto the screen directly.</p><p>Direct screen rendering opens a possibility for another amazing optimization technique called occlusion culling. In the new renderer, PixiEditor will only draw chunks you see on the screen, if you zoom the\nviewport, chunks outside the visible area won’t be rendered.</p><p>Here’s a preview with shrunk visible area to see the effect</p><p>Furthermore, if you have a document with a graph, that consists of layers only, drawing shouldn’t allocate more memory than amount of chunks required. So creating huge documents by itself won’t cause memory problems for PixiEditor.\nSaving .pixi files will also save filled chunks only.</p><p>Please note that the new renderer is not yet released. It will require some more testing before it lands in the development version.</p><h3>Slice Text, Character Position and Text Info</h3><p>We’ve added a few new nodes for text manipulation.</p><img src=\"https://pixieditor.net/_astro/text-nodes.CLpj3whq_1cyGuo.webp\" alt=\"Text nodes example\" width=\"1025\" height=\"338\" loading=\"lazy\" decoding=\"async\"><p>And here’s a quick demo of what you can do with them</p><p>The Posterize node reduces the number of colors in an image, creating a stylized effect. It works by mapping the colors in the input image to a limited set of colors based on the specified number of levels.</p><p>We added a node for that. There are 2 modes available: RGB and Luminance. The latter will produce grayscale posterization.</p><img src=\"https://pixieditor.net/_astro/posterize.Cuzq6ReU_nJMTd.webp\" alt=\"Posterize node example\" width=\"2040\" height=\"1536\" loading=\"lazy\" decoding=\"async\"><p>We are still working on fixes and improvements after the 2.0 release along with a Brush Engine. Hopefully I’ll have more news about it in October status update.</p><div data-astro-cid-zdvwf2lx=\"\"><p data-astro-cid-zdvwf2lx=\"\"> is fully funded by the community - please consider supporting us with the !\n</p><a href=\"https://pixieditor.net/download\" target=\"_blank\" data-astro-cid-zdvwf2lx=\"\">Support Now</a></div><p>Also, thanks to Sebasthem for letting us use a photo of this cute kitty! \nSebasthem’s <a href=\"https://www.instagram.com/p/DNm5RyyODL0/?igsh=MWg0NjM4Z21kdGNoMA==\">Instagram</a></p><p>Thank you for reading, see you next month!</p>","contentLength":8008,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1nvyajf/pixieditor_is_now_available_on_flathub/"},{"title":"Running Blender on Linux with Termux:X11","url":"https://www.reddit.com/r/linux/comments/1nvxlvg/running_blender_on_linux_with_termuxx11/","date":1759391479,"author":"/u/OutrageousPassion678","guid":633,"unread":true,"content":"<p>This runs 100% local and offline. Phone is a moto edge 2024 running Debian with xfce4 on Termux with X11. Increased the scale in X11 settings for better usability and performance. Screen recording here: <a href=\"https://imgur.com/a/hG2jls8\">https://imgur.com/a/hG2jls8</a></p>","contentLength":230,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit"]}