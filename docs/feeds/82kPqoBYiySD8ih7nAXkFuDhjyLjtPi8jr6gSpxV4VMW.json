{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"Flight Recorder in Go 1.25","url":"https://go.dev/blog/flight-recorder","date":1758844800,"author":"Carlos Amedee and Michael Knyszek","guid":175,"unread":true,"content":"<p>In 2024 we introduced the world to\n<a href=\"https://go.dev/blog/execution-traces-2024\">more powerful Go execution traces</a>. In that blog post\nwe gave a sneak peek into some of the new functionality we could unlock with our new execution\ntracer, including . We’re happy to announce that flight recording is now\navailable in Go 1.25, and it’s a powerful new tool in the Go diagnostics toolbox.</p><p>First, a quick recap on Go execution traces.</p><p>The Go runtime can be made to write a log recording many of the events that happen during\nthe execution of a Go application. That log is called a runtime execution trace.\nGo execution traces contain a plethora of information about how goroutines interact with each\nother and the underlying system. This makes them very handy for debugging latency issues, since\nthey tell you both when your goroutines are executing, and crucially, when they are not.</p><p>The <a href=\"https://go.dev/pkg/runtime/trace\">runtime/trace</a> package provides an API for collecting\nan execution trace over a given time window by calling  and .\nThis works well if the code you’re tracing is just a test, microbenchmark, or command line\ntool. You can collect a trace of the complete end-to-end execution, or just the parts you care about.</p><p>However, in long-running web services, the kinds of applications Go is known for, that’s not\ngood enough. Web servers might be up for days or even weeks, and collecting a trace of the\nentire execution would produce far too much data to sift through. Often just one part\nof the program’s execution goes wrong, like a request timing out or a failed health\ncheck. By the time it happens it’s already too late to call !</p><p>One way to approach this problem is to randomly sample execution traces from across the fleet.\nWhile this approach is powerful, and can help find issues before they become outages, it\nrequires a lot of infrastructure to get going. Large quantities of execution trace data\nwould need to be stored, triaged, and processed, much of which won’t contain anything\ninteresting at all. And when you’re trying to get to the bottom of a specific issue,\nit’s a non-starter.</p><p>This brings us to the flight recorder.</p><p>A program often knows when something has gone wrong, but the root cause may have happened\nlong ago. The flight recorder lets you collect a trace of the last few seconds of\nexecution leading up to the moment a program detects there’s been a problem.</p><p>The flight recorder collects the execution trace as normal, but instead of writing it out to\na socket or a file, it buffers the last few seconds of the trace in memory. At any point,\nthe program can request the contents of the buffer and snapshot exactly the problematic\nwindow of time. The flight recorder is like a scalpel cutting directly to the problem area.</p><p>Let’s learn how to use the flight recorder with an example. Specifically, let’s use it to\ndiagnose a performance problem with an HTTP server that implements a “guess the number” game.\nIt exposes a  endpoint that accepts an integer and responds to the caller\ninforming them if they guessed the right number. There is also a goroutine that, once per\nminute, sends a report of all the guessed numbers to another service via an HTTP request.</p><pre><code>// bucket is a simple mutex-protected counter.\ntype bucket struct {\n    mu      sync.Mutex\n    guesses int\n}\n\nfunc main() {\n    // Make one bucket for each valid number a client could guess.\n    // The HTTP handler will look up the guessed number in buckets by\n    // using the number as an index into the slice.\n    buckets := make([]bucket, 100)\n\n    // Every minute, we send a report of how many times each number was guessed.\n    go func() {\n        for range time.Tick(1 * time.Minute) {\n            sendReport(buckets)\n        }\n    }()\n\n    // Choose the number to be guessed.\n    answer := rand.Intn(len(buckets))\n\n    http.HandleFunc(\"/guess-number\", func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n\n        // Fetch the number from the URL query variable \"guess\" and convert it\n        // to an integer. Then, validate it.\n        guess, err := strconv.Atoi(r.URL.Query().Get(\"guess\"))\n        if err != nil || !(0 &lt;= guess &amp;&amp; guess &lt; len(buckets)) {\n            http.Error(w, \"invalid 'guess' value\", http.StatusBadRequest)\n            return\n        }\n\n        // Select the appropriate bucket and safely increment its value.\n        b := &amp;buckets[guess]\n        b.mu.Lock()\n        b.guesses++\n        b.mu.Unlock()\n\n        // Respond to the client with the guess and whether it was correct.\n        fmt.Fprintf(w, \"guess: %d, correct: %t\", guess, guess == answer)\n\n        log.Printf(\"HTTP request: endpoint=/guess-number guess=%d duration=%s\", guess, time.Since(start))\n    })\n    log.Fatal(http.ListenAndServe(\":8090\", nil))\n}\n\n// sendReport posts the current state of buckets to a remote service.\nfunc sendReport(buckets []bucket) {\n    counts := make([]int, len(buckets))\n\n    for index := range buckets {\n        b := &amp;buckets[index]\n        b.mu.Lock()\n        defer b.mu.Unlock()\n\n        counts[index] = b.guesses\n    }\n\n    // Marshal the report data into a JSON payload.\n    b, err := json.Marshal(counts)\n    if err != nil {\n        log.Printf(\"failed to marshal report data: error=%s\", err)\n        return\n    }\n    url := \"http://localhost:8091/guess-number-report\"\n    if _, err := http.Post(url, \"application/json\", bytes.NewReader(b)); err != nil {\n        log.Printf(\"failed to send report: %s\", err)\n    }\n}\n</code></pre><p>Let’s suppose that after deploying the application in production, we received complaints from\nusers that some  calls were taking longer than expected. When we look at our\nlogs, we see that sometimes response times exceed 100 milliseconds, while the majority of calls\nare on the order of microseconds.</p><pre><code>2025/09/19 16:52:02 HTTP request: endpoint=/guess-number guess=69 duration=625ns\n2025/09/19 16:52:02 HTTP request: endpoint=/guess-number guess=62 duration=458ns\n2025/09/19 16:52:02 HTTP request: endpoint=/guess-number guess=42 duration=1.417µs\n2025/09/19 16:52:02 HTTP request: endpoint=/guess-number guess=86 duration=115.186167ms\n2025/09/19 16:52:02 HTTP request: endpoint=/guess-number guess=0 duration=127.993375ms\n</code></pre><p>Before we continue, take a minute and see if you can spot what’s wrong!</p><p>Regardless of whether you found the problem or not, let’s dive deeper and see how we can\nfind the problem from first principles. In particular, it would be great if we could see\nwhat the application was doing in the time leading up to the slow response. This is exactly\nwhat the flight recorder was built for! We’ll use it to capture an execution trace once\nwe see the first response exceeding 100 milliseconds.</p><p>First, in , we’ll configure and start the flight recorder:</p><pre><code>// Set up the flight recorder\nfr := trace.NewFlightRecorder(trace.FlightRecorderConfig{\n    MinAge:   200 * time.Millisecond,\n    MaxBytes: 1 &lt;&lt; 20, // 1 MiB\n})\nfr.Start()\n</code></pre><p> configures the duration for which trace data is reliably retained, and we\nsuggest setting it to around 2x the time window of the event. For example, if you\nare debugging a 5-second timeout, set it to 10 seconds.  configures the\nsize of the buffered trace so you don’t blow up your memory usage.  On average,\nyou can expect a few MB of trace data to be produced per second of execution,\nor 10 MB/s for a busy service.</p><p>Next, we’ll add a helper function to capture the snapshot and write it to a file:</p><pre><code>var once sync.Once\n\n// captureSnapshot captures a flight recorder snapshot.\nfunc captureSnapshot(fr *trace.FlightRecorder) {\n    // once.Do ensures that the provided function is executed only once.\n    once.Do(func() {\n        f, err := os.Create(\"snapshot.trace\")\n        if err != nil {\n            log.Printf(\"opening snapshot file %s failed: %s\", f.Name(), err)\n            return\n        }\n        defer f.Close() // ignore error\n\n        // WriteTo writes the flight recorder data to the provided io.Writer.\n        _, err = fr.WriteTo(f)\n        if err != nil {\n            log.Printf(\"writing snapshot to file %s failed: %s\", f.Name(), err)\n            return\n        }\n\n        // Stop the flight recorder after the snapshot has been taken.\n        fr.Stop()\n        log.Printf(\"captured a flight recorder snapshot to %s\", f.Name())\n    })\n}\n</code></pre><p>And finally, just before logging a completed request, we’ll trigger the snapshot if the request\ntook more than 100 milliseconds:</p><pre><code>// Capture a snapshot if the response takes more than 100ms.\n// Only the first call has any effect.\nif fr.Enabled() &amp;&amp; time.Since(start) &gt; 100*time.Millisecond {\n    go captureSnapshot(fr)\n}\n</code></pre><p>Now, we run the server again and send requests until we get a slow request that triggers a\nsnapshot.</p><p>Once we’ve gotten a trace, we’ll need a tool that will help us examine it. The Go toolchain\nprovides a built-in execution trace analysis tool via the\n<a href=\"https://pkg.go.dev/cmd/trace\" rel=\"noreferrer\" target=\"_blank\"> command</a>. Run <code>go tool trace snapshot.trace</code> to\nlaunch the tool, which starts a local web server, then open the displayed URL in your browser\n(if the tool doesn’t open your browser automatically).</p><p>This tool gives us a few ways to look at the trace, but let’s focus on visualizing the trace\nto get a sense of what’s going on. Click “View trace by proc” to do so.</p><p>In this view, the trace is presented as a timeline of events. At the top of the page, in\nthe “STATS” section, we can see a summary of the application’s state, including the\nnumber of threads, the heap size, and the goroutine count.</p><p>Below that, in the “PROCS” section, we can see how the execution of goroutines is mapped\nonto  (the number of operating system threads created by the Go application). We\ncan see when and how each goroutine starts, runs, and finally stops executing.</p><p>For now, let’s turn our attention to this massive gap in execution on the right side of the\nviewer. For a period of time, around 100ms, nothing is happening!</p><p>By selecting the  tool (or pressing ), we can inspect the section of the trace right\nafter the gap with more detail.</p><p>In addition to the activity of each individual goroutine, we can see how goroutines interact\nvia “flow events.” An incoming flow event indicates what happened to make a goroutine start\nrunning. An outgoing flow edge indicates what effect one goroutine had on another. Enabling the\nvisualization of all flow events often provides clues that hint at the source of a problem.</p><p>In this case, we can see that many of the goroutines have a direct connection to a single\ngoroutine right after the pause in activity.</p><p>Clicking on the the single goroutine shows an event table filled with outgoing flow events, which\nmatches what we saw when the flow view was enabled.</p><p>What happened when this goroutine ran? Part of the information stored in the trace is a view\nof the stack trace at different points in time. When we look at the goroutine we can see that\nthe start stack trace shows that it was waiting for the HTTP request to complete when the\ngoroutine was scheduled to run. And the end stack trace shows that the  function\nhad already returned and it was waiting for the ticker for the next scheduled time to send\nthe report.</p><p>Between the start and the end of this goroutine running, we see a huge number of\n“outgoing flows,” where it interacts with other goroutines. Clicking on one of the\n entries takes us to a view of the interaction.</p><p>This flow implicates the  in :</p><pre><code>for index, b := range buckets {\n    b.mu.Lock()\n    defer b.mu.Unlock()\n\n    counts[index] = b.value\n}\n</code></pre><p>In , we intended to acquire a lock on each bucket and release the lock after\ncopying the value.</p><p>But here’s the problem: we don’t actually release the lock immediately after copying the\nvalue contained in . Because we used a  statement to release the\nlock, that release doesn’t happen until the function returns. We hold the lock not just\npast the end of the loop, but until after the HTTP request completes. That’s a subtle\nerror that may be difficult to track down in a large production system.</p><p>Fortunately, execution tracing helped us pinpoint the problem. However, if we tried\nto use the execution tracer in a long-running server without the new flight-recording\nmode, it would likely amass a huge amount of execution trace data, which an operator\nwould have to store, transmit, and sift through. The flight recorder gives us the power\nof hindsight. It lets us capture just what went wrong, after it’s already happened,\nand quickly zero in on the cause.</p><p>The flight recorder is just the latest addition to the Go developer’s toolbox for\ndiagnosing the inner workings of running applications. We’ve steadily been improving\ntracing over the past couple of releases. Go 1.21 greatly reduced the run-time overhead\nof tracing. The trace format became more robust and also splittable in the Go 1.22\nrelease, leading to features like the flight recorder. Open-source tools like\n<a href=\"https://gotraceui.dev/\" rel=\"noreferrer\" target=\"_blank\">gotraceui</a>, and the <a href=\"https://go.dev/issue/62627\">forthcoming ability to programmatically\nparse execution traces</a> are more ways to leverage the power of\nexecution traces. The <a href=\"https://go.dev/doc/diagnostics\">Diagnostics page</a> lists many additional\ntools at your disposal. We hope you make use of them as you write and refine\nyour Go applications.</p><p>We’d like to take a moment to thank those community members who have been active in the\ndiagnostics meetings, contributed to the designs, and provided feedback over the years:\nFelix Geisendörfer (<a href=\"https://bsky.app/profile/felixge.de\" rel=\"noreferrer\" target=\"_blank\">@felixge.de</a>),\nNick Ripley (<a href=\"https://github.com/nsrip-dd\" rel=\"noreferrer\" target=\"_blank\">@nsrip-dd</a>),\nRhys Hiltner (<a href=\"https://github.com/rhysh\" rel=\"noreferrer\" target=\"_blank\">@rhysh</a>),\nDominik Honnef (<a href=\"https://github.com/dominikh\" rel=\"noreferrer\" target=\"_blank\">@dominikh</a>),\nBryan Boreham (<a href=\"https://github.com/bboreham\" rel=\"noreferrer\" target=\"_blank\">@bboreham</a>),\nand PJ Malloy (<a href=\"https://github.com/thepudds\" rel=\"noreferrer\" target=\"_blank\">@thepudds</a>).</p><p>The discussions, feedback, and work you’ve all put in have been instrumental in pushing\nus to a better diagnostics future. Thank you!</p>","contentLength":13510,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"It's survey time! How has Go has been working out for you?","url":"https://go.dev/blog/survey2025-announce","date":1757980800,"author":"Todd Kulesza, on behalf of the Go team","guid":174,"unread":true,"content":"<p>Hi Gophers! Today we’re excited to announce our <a href=\"https://google.qualtrics.com/jfe/form/SV_3wwSstC8vv4Ymkm?s=b\" rel=\"noreferrer\" target=\"_blank\">2025 Go Developer Survey</a>. The Go Team uses the results of this annual survey to better understand the needs and concerns of Go developers across the world. Your feedback helps us brainstorm, plan, and prioritize work on Go.</p><p>You can <a href=\"https://google.qualtrics.com/jfe/form/SV_3wwSstC8vv4Ymkm?s=b\" rel=\"noreferrer\" target=\"_blank\">take the survey here</a>. It will be open through . The survey should take 10 – 20 minutes to complete, and every question is optional.</p><p>We’ll share aggregated survey results on this blog in early November. This year we’ll also share the raw dataset of survey responses, so that the entire Go community can benefit from this knowledge and conduct your own analyses on the data. Similar to our approach with <a href=\"https://go.dev/blog/gotelemetry\">Go Telemetry</a>, we’re using an opt-in model: the survey will ask for your permission to include your responses in the dataset. If you don’t give us permission, your survey responses will not be shared.</p><p>Please help us reach as many Go developers as possible! We love it when you share the survey with your colleagues, friends, and online communities. The more voices we hear, the better we can understand the diverse needs of Go developers everywhere.</p><p>We’re looking forward to hearing your feedback!</p>","contentLength":1188,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"A new experimental Go API for JSON","url":"https://go.dev/blog/jsonv2-exp","date":1757376000,"author":"Joe Tsai, Daniel Martí, Johan Brandhorst-Satzkorn, Roger Peppe, Chris Hines, and Damien Neil","guid":173,"unread":true,"content":"<p><a href=\"https://datatracker.ietf.org/doc/html/rfc8259\" rel=\"noreferrer\" target=\"_blank\">JavaScript Object Notation (JSON)</a>\nis a simple data interchange format. Almost 15 years ago,\nwe wrote about <a href=\"https://go.dev/blog/json\">support for JSON in Go</a>,\nwhich introduced the ability to serialize and deserialize Go types to and from JSON data.\nSince then, JSON has become the most popular data format used on the Internet.\nIt is widely read and written by Go programs,\nand encoding/json now ranks as the 5th most imported Go package.</p><p>Over time, packages evolve with the needs of their users,\nand  is no exception. This blog post is about Go 1.25’s new\nexperimental  and  packages,\nwhich bring long-awaited improvements and fixes.\nThis post argues for a new major API version,\nprovides an overview of the new packages,\nand explains how you can make use of it.\nThe experimental packages are not visible by default and\nmay undergo future API changes.</p><h2>Problems with </h2><p>Overall,  has held up well.\nThe idea of marshaling and unmarshaling arbitrary Go types\nwith some default representation in JSON, combined with the ability to\ncustomize the representation, has proven to be highly flexible.\nHowever, in the years since its introduction,\nvarious users have identified numerous shortcomings.</p><p>There are various behavioral flaws in :</p><ul><li><p><strong>Imprecise handling of JSON syntax</strong>: Over the years, JSON has seen\nincreased standardization in order for programs to properly communicate.\nGenerally, decoders have become stricter at rejecting ambiguous inputs,\nto reduce the chance that two implementations will have different\n(successful) interpretations of a particular JSON value.</p><ul><li><p> currently accepts invalid UTF-8,\nwhereas the latest Internet Standard (RFC 8259) requires valid UTF-8.\nThe default behavior should report an error in the presence of invalid UTF-8,\ninstead of introducing silent data corruption,\nwhich may cause problems downstream.</p></li><li><p> currently accepts objects with duplicate member names.\nRFC 8259 does not specify how to handle duplicate names,\nso an implementation is free to choose an arbitrary value,\nmerge the values, discard the values, or report an error.\nThe presence of a duplicate name results in a JSON value\nwithout a universally agreed upon meaning.\nThis could be <a href=\"https://www.youtube.com/watch?v=avilmOcHKHE&amp;t=1057s\" rel=\"noreferrer\" target=\"_blank\">exploited by attackers in security applications</a>\nand has been exploited before (as in <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-12635\" rel=\"noreferrer\" target=\"_blank\">CVE-2017-12635</a>).\nThe default behavior should err on the side of safety and reject duplicate names.</p></li></ul></li><li><p><strong>Leaking nilness of slices and maps</strong>: JSON is often used to communicate with\nprograms using JSON implementations that do not allow  to be unmarshaled\ninto a data type expected to be a JSON array or object.\nSince  marshals a nil slice or map as a JSON ,\nthis may lead to errors when unmarshaling by other implementations.\n<a href=\"https://go.dev/issue/63397#discussioncomment-7201222\">A survey</a>\nindicated that most Go users prefer that nil slices and maps\nare marshaled as an empty JSON array or object by default.</p></li><li><p><strong>Case-insensitive unmarshaling</strong>: When unmarshaling, a JSON object member name\nis resolved to a Go struct field name using a case-insensitive match.\nThis is a surprising default, a potential security vulnerability, and a performance limitation.</p></li><li><p><strong>Inconsistent calling of methods</strong>: Due to an implementation detail,\n methods declared on a pointer receiver\nare <a href=\"https://go.dev/issue/22967\">inconsistently called by </a>. While regarded as a bug,\nthis cannot be fixed as too many applications depend on the current behavior.</p></li></ul><p>The API of  can be tricky or restrictive:</p><ul><li><p>It is difficult to correctly unmarshal from an .\nUsers often write <code>json.NewDecoder(r).Decode(v)</code>,\nwhich fails to reject trailing junk at the end of the input.</p></li><li><p>Options can be set on the  and  types,\nbut cannot be used with the  and  functions.\nSimilarly, types implementing the  and  interfaces\ncannot make use of the options and there is no way to plumb options down the call stack.\nFor example, the <code>Decoder.DisallowUnknownFields</code> option loses its effect\nwhen calling a custom  method.</p></li><li><p>The , , and  functions write to a \ninstead of something more flexible like a  or .\nThis limits the usability of those functions.</p></li></ul><p>Setting aside internal implementation details,\nthe public API commits it to certain performance limitations:</p><ul><li><p>: The  interface method forces the implementation\nto allocate the returned . Also, the semantics require that\n verify that the result is valid JSON\nand also to reformat it to match the specified indentation.</p></li><li><p>: The  interface method requires that\na complete JSON value be provided (without any trailing data).\nThis forces  to parse the JSON value to be unmarshaled\nin its entirety to determine where it ends before it can call .\nAfterwards, the  method itself must parse the provided JSON value again.</p></li><li><p>: Even though the  and  types operate\non an  or , they buffer the entire JSON value in memory.\nThe  method for reading individual tokens is allocation-heavy\nand there is no corresponding API for writing tokens.</p></li></ul><p>Furthermore, if the implementation of a  or  method\nrecursively calls the  or  function,\nthen the performance becomes quadratic.</p><h2>Trying to fix  directly</h2><p>Introducing a new, incompatible major version of a package is a heavy consideration.\nIf possible, we should try to fix the existing package.</p><p>While it is relatively easy to add new features,\nit is difficult to change existing features.\nUnfortunately, these problems are inherent consequences of the existing API,\nmaking them practically impossible to fix within the <a href=\"https://go.dev/doc/go1compat\">Go 1 compatibility promise</a>.</p><p>We could in principle declare separate names, such as  or ,\nbut that is tantamount to creating a parallel namespace within the same package.\nThis leads us to  (henceforth called ),\nwhere we can make these changes within a separate  namespace\nin contrast to  (henceforth called ).</p><h2>Planning for </h2><p>The planning for a new major version of  spanned years.\nIn late 2020, spurred on by the inability to fix issues in the current package,\nDaniel Martí (one of the maintainers of ) first drafted his\nthoughts on <a href=\"https://docs.google.com/document/d/1WQGoM44HLinH4NGBEv5drGlw5_RNW-GP7DdGEpm7Y3o\" rel=\"noreferrer\" target=\"_blank\">what a hypothetical  package should look like</a>.\nSeparately, after previous work on the <a href=\"https://go.dev/blog/protobuf-apiv2\">Go API for Protocol Buffers</a>,\nJoe Tsai was disapppointed that <a href=\"https://go.dev/pkg/google.golang.org/protobuf/encoding/protojson\">the  package</a>\nneeded to use a custom JSON implementation because  was\nneither capable of adhering to the stricter JSON standard that the\nProtocol Buffer specification required,\nnor of efficiently serializing JSON in a streaming manner.</p><p>Believing a brighter future for JSON was both beneficial and achievable,\nDaniel and Joe joined forces to brainstorm on  and\n<a href=\"https://github.com/go-json-experiment/json\" rel=\"noreferrer\" target=\"_blank\">started to build a prototype</a>\n(with the initial code being a polished version of the JSON serialization logic from the Go protobuf module).\nOver time, a few others (Roger Peppe, Chris Hines, Johan Brandhorst-Satzkorn, and Damien Neil)\njoined the effort by providing design review, code review, and regression testing.\nMany of the early discussions are publicly available in our\n<a href=\"https://www.youtube.com/playlist?list=PLZgrQPcV8W8EChkaAvv-3NUu6PYmnGG3b\" rel=\"noreferrer\" target=\"_blank\">recorded meetings</a> and\n<a href=\"https://docs.google.com/document/d/1rovrOTd-wTawGMPPlPuKhwXaYBg9VszTXR9AQQL5LfI\" rel=\"noreferrer\" target=\"_blank\">meeting notes</a>.</p><p>The  effort has been going on for 5 years,\nincorporating feedback from many contributors and also gaining valuable\nempirical experience from use in production settings.</p><p>It’s worth noting that it’s largely been developed and promoted by people\nnot employed by Google, demonstrating that the Go project is a collaborative endeavor\nwith a thriving global community dedicated to improving the Go ecosystem.</p><h2>Building on </h2><p>Before discussing the  API, we first introduce the experimental\n<a href=\"https://go.dev/pkg/encoding/json/jsontext\"></a> package\nthat lays the foundation for future improvements to JSON in Go.</p><p>JSON serialization in Go can be broken down into two primary components:</p><ul><li> that is concerned with processing JSON based on its grammar, and</li><li> that defines the relationship between JSON values and Go values.</li></ul><p>We use the terms “encode” and “decode” to describe syntactic functionality and\nthe terms “marshal” and “unmarshal” to describe semantic functionality.\nWe aim to provide a clear distinction between functionality\nthat is purely concerned with encoding versus that of marshaling.</p><img src=\"https://go.dev/blog/jsonv2-exp/api.png\" width=\"100%\"><p>This diagram provides an overview of this separation.\nPurple blocks represent types, while blue blocks represent functions or methods.\nThe direction of the arrows approximately represents the flow of data.\nThe bottom half of the diagram, implemented by the  package,\ncontains functionality that is only concerned with syntax,\nwhile the upper half, implemented by the  package,\ncontains functionality that assigns semantic meaning to syntactic data\nhandled by the bottom half.</p><p>The basic API of  is the following:</p><pre><code>package jsontext\n\ntype Encoder struct { ... }\nfunc NewEncoder(io.Writer, ...Options) *Encoder\nfunc (*Encoder) WriteValue(Value) error\nfunc (*Encoder) WriteToken(Token) error\n\ntype Decoder struct { ... }\nfunc NewDecoder(io.Reader, ...Options) *Decoder\nfunc (*Decoder) ReadValue() (Value, error)\nfunc (*Decoder) ReadToken() (Token, error)\n\ntype Kind byte\ntype Value []byte\nfunc (Value) Kind() Kind\ntype Token struct { ... }\nfunc (Token) Kind() Kind\n</code></pre><p>The  package provides functionality for interacting with JSON\nat a syntactic level and derives its name from\n<a href=\"https://datatracker.ietf.org/doc/html/rfc8259#section-2\" rel=\"noreferrer\" target=\"_blank\">RFC 8259, section 2</a>\nwhere the grammar for JSON data is literally called .\nSince it only interacts with JSON at a syntactic level,\nit does not depend on Go reflection.</p><p>The <a href=\"https://go.dev/pkg/encoding/json/jsontext#Encoder\"></a> and\n<a href=\"https://go.dev/pkg/encoding/json/jsontext#Decoder\"></a>\nprovide support for encoding and decoding JSON values and tokens.\nThe constructors\n<a href=\"https://go.dev/pkg/encoding/json/jsontext#Options\">accept variadic options</a>\nthat affect the particular behavior of encoding and decoding.\nUnlike the  and  types declared in ,\nthe new types in  avoid muddling the distinction between syntax and\nsemantics and operate in a truly streaming manner.</p><p>A JSON value is a complete unit of data and is represented in Go as\n<a href=\"https://go.dev/pkg/encoding/json/jsontext#Value\">a named </a>.\nIt is identical to <a href=\"https://go.dev/pkg/encoding/json#RawMessage\"></a> in .\nA JSON value is syntactically composed of one or more JSON tokens.\nA JSON token is represented in Go as the <a href=\"https://go.dev/pkg/encoding/json/jsontext#Token\">opaque  type</a>\nwith constructors and accessor methods.\nIt is analogous to <a href=\"https://go.dev/pkg/encoding/json#Token\"></a> in \nbut is designed represent arbitrary JSON tokens without allocation.</p><p>To resolve the fundamental performance problems with\nthe  and  interface methods,\nwe need an efficient way of encoding and decoding JSON\nas a streaming sequence of tokens and values.\nIn , we introduce the  and  interface methods\nthat operate on an  or , allowing the methods’ implementations\nto process JSON in a purely streaming manner. Thus, the  package need not\nbe responsible for validating or formatting a JSON value returned by ,\nnor would it need to be responsible for determining the boundaries of a JSON value\nprovided to . These responsibilities belong to the  and .</p><h2>Introducing </h2><p>Building on the  package, we now introduce the experimental\n<a href=\"https://go.dev/pkg/encoding/json/v2\"></a> package.\nIt is designed to fix the aforementioned problems,\nwhile remaining familiar to users of the  package.\nOur goal is that usages of  will operate  the same if directly migrated to .</p><p>The basic API of  is the following:</p><pre><code>package json\n\nfunc Marshal(in any, opts ...Options) (out []byte, err error)\nfunc MarshalWrite(out io.Writer, in any, opts ...Options) error\nfunc MarshalEncode(out *jsontext.Encoder, in any, opts ...Options) error\n\nfunc Unmarshal(in []byte, out any, opts ...Options) error\nfunc UnmarshalRead(in io.Reader, out any, opts ...Options) error\nfunc UnmarshalDecode(in *jsontext.Decoder, out any, opts ...Options) error\n</code></pre><p>The <a href=\"https://go.dev/pkg/encoding/json/v2#Marshal\"></a>\nand <a href=\"https://go.dev/pkg/encoding/json/v2#Unmarshal\"></a> functions\nhave a signature similar to , but accept options to configure their behavior.\nThe <a href=\"https://go.dev/pkg/encoding/json/v2#MarshalWrite\"></a>\nand <a href=\"https://go.dev/pkg/encoding/json/v2#UnmarshalRead\"></a> functions\ndirectly operate on an  or ,\navoiding the need to temporarily construct an  or \njust to write or read from such types.\nThe <a href=\"https://go.dev/pkg/encoding/json/v2#MarshalEncode\"></a>\nand <a href=\"https://go.dev/pkg/encoding/json/v2#UnmarshalDecode\"></a> functions\noperate on a  and  and\nis actually the underlying implementation of the previously mentioned functions.\nUnlike , options are a first-class argument to each of the marshal and unmarshal functions,\ngreatly extending the flexibility and configurability of .\nThere are <a href=\"https://go.dev/pkg/encoding/json/v2#Options\">several options available</a>\nin  which are not covered by this article.</p><h3>Type-specified customization</h3><p>Similar to ,  allows types to define their own JSON representation\nby satisfying particular interfaces.</p><pre><code>type Marshaler interface {\n    MarshalJSON() ([]byte, error)\n}\ntype MarshalerTo interface {\n    MarshalJSONTo(*jsontext.Encoder) error\n}\n\ntype Unmarshaler interface {\n    UnmarshalJSON([]byte) error\n}\ntype UnmarshalerFrom interface {\n    UnmarshalJSONFrom(*jsontext.Decoder) error\n}\n</code></pre><p>The <a href=\"https://go.dev/pkg/encoding/json/v2#Marshaler\"></a>\nand <a href=\"https://go.dev/pkg/encoding/json/v2#Unmarshaler\"></a> interfaces\nare identical to those in .\nThe new <a href=\"https://go.dev/pkg/encoding/json/v2#MarshalerTo\"></a>\nand <a href=\"https://go.dev/pkg/encoding/json/v2#UnmarshalerFrom\"></a> interfaces\nallow a type to represent itself as JSON using a  or .\nThis allows options to be forwarded down the call stack, since options\ncan be retrieved via the  accessor method on the  or .</p><h3>Caller-specified customization</h3><p>In , the caller of  and  can also specify\na custom JSON representation for any arbitrary type,\nwhere caller-specified functions take precedence over type-defined methods\nor the default representation for a particular type.</p><pre><code>func WithMarshalers(*Marshalers) Options\n\ntype Marshalers struct { ... }\nfunc MarshalFunc[T any](fn func(T) ([]byte, error)) *Marshalers\nfunc MarshalToFunc[T any](fn func(*jsontext.Encoder, T) error) *Marshalers\n\nfunc WithUnmarshalers(*Unmarshalers) Options\n\ntype Unmarshalers struct { ... }\nfunc UnmarshalFunc[T any](fn func([]byte, T) error) *Unmarshalers\nfunc UnmarshalFromFunc[T any](fn func(*jsontext.Decoder, T) error) *Unmarshalers\n</code></pre><p>While  aims to behave  the same as ,\nits behavior has changed <a href=\"https://go.dev/pkg/github.com/go-json-experiment/json/v1#hdr-Migrating_to_v2\">in some ways</a>\nto address problems in , most notably:</p><ul><li><p> reports an error in the presence of invalid UTF-8.</p></li><li><p> reports an error if a JSON object contains a duplicate name.</p></li><li><p> marshals a nil Go slice or Go map as an empty JSON array or JSON object, respectively.</p></li><li><p> unmarshals a JSON object into a Go struct using a\ncase-sensitive match from the JSON member name to the Go field name.</p></li><li><p> redefines the  tag option to omit a field if it would have\nencoded as an “empty” JSON value (which are , , , and ).</p></li><li><p> reports an error when trying to serialize a ,\nwhich currently has <a href=\"https://go.dev/issue/71631\">no default representation</a>,\nbut provides options to let the caller decide.</p></li></ul><p>For most behavior changes, there is a struct tag option or caller-specified option\nthat can configure the behavior to operate under  or  semantics,\nor even other caller-determined behavior.\nSee <a href=\"https://go.dev/pkg/github.com/go-json-experiment/json/v1#hdr-Migrating_to_v2\">“Migrating to v2”</a> for more information.</p><p>The  performance of  is roughly at parity with .\nSometimes it is slightly faster, but other times it is slightly slower.\nThe  performance of  is significantly faster than ,\nwith benchmarks demonstrating improvements of up to 10x.</p><p>In order to obtain greater performance gains,\nexisting implementations of\n<a href=\"https://go.dev/pkg/encoding/json/v2#Marshaler\"></a> and\n<a href=\"https://go.dev/pkg/encoding/json/v2#Unmarshaler\"></a> should\nmigrate to also implement\n<a href=\"https://go.dev/pkg/encoding/json/v2#MarshalerTo\"></a> and\n<a href=\"https://go.dev/pkg/encoding/json/v2#UnmarshalerFrom\"></a>,\nso that they can benefit from processing JSON in a purely streaming manner.\nFor example, recursive parsing of OpenAPI specifications in  methods\nsignificantly hurt performance in a particular service of Kubernetes\n(see <a href=\"https://github.com/kubernetes/kube-openapi/issues/315\" rel=\"noreferrer\" target=\"_blank\">kubernetes/kube-openapi#315</a>),\nwhile switching to  improved performance by orders of magnitude.</p><h2>Retroactively improving </h2><p>We want to avoid two separate JSON implementations in the Go standard library,\nso it is critical that, under the hood,  is implemented in terms of .</p><p>There are several benefits to this approach:</p><ol><li><p>: The  and  functions in  or \nrepresent a set of default behaviors that operate according to  or  semantics.\nOptions can be specified that configure  or  to operate with\nentirely , mostly  with a some , a mix of  or ,\nmostly  with some , or entirely  semantics.\nThis allows for gradual migration between the default behaviors of the two versions.</p></li><li><p>: As backward-compatible features are added to ,\nthey will inherently be made available in . For example,  adds\nsupport for several new struct tag options such as  or  and also\nsupport for the  and  interface methods,\nwhich are both more performant and flexible.\nWhen  is implemented in terms of , it will inherit support for these features.</p></li><li><p>: Maintenance of a widely used package demands significant effort.\nBy having  and  use the same implementation, the maintenance burden is reduced.\nIn general, a single change will fix bugs, improve performance, or add functionality to both versions.\nThere is no need to backport a  change with an equivalent  change.</p></li></ol><p>While select parts of  may be deprecated over time (supposing  graduates from being an experiment),\nthe package as a whole will never be deprecated.\nMigrating to  will be encouraged, but not required.\nThe Go project will not drop support for .</p><p>The newer API in the  and  packages are not visible by default.\nTo use them, build your code with  set in your environment or with the  build tag.\nThe nature of an experiment is that the API is unstable and may change in the future.\nThough the API is unstable, the implementation is of a high quality and\nhas been successfully used in production by several major projects.</p><p>The fact that  is implemented in terms of  means that the underlying implementation of \nis completely different when building under the  experiment.\nWithout changing any code, you should be able to run your tests\nunder  and theoretically nothing new should fail:</p><pre><code>GOEXPERIMENT=jsonv2 go test ./...\n</code></pre><p>The re-implementation of  in terms of  aims to provide identical behavior\nwithin the bounds of the <a href=\"https://go.dev/doc/go1compat\">Go 1 compatibility promise</a>,\nthough some differences might be observable such as the exact wording of error messages.\nWe encourage you to run your tests under  and\nreport any regressions <a href=\"https://go.dev/issues\">on the issue tracker</a>.</p><p>Becoming an experiment in Go 1.25 is a significant milestone on the road to\nformally adopting  and  into the standard library.\nHowever, the purpose of the  experiment is to gain broader experience.\nYour feedback will determine our next steps, and the outcome of this experiment,\nwhich may result in anything from abandonment of the effort, to adoption as stable packages of Go 1.26.\nPlease share your experience on <a href=\"https://go.dev/issue/71497\">go.dev/issue/71497</a>, and help determine the future of Go.</p>","contentLength":17378,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}